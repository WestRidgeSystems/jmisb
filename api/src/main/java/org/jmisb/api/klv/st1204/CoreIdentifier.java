package org.jmisb.api.klv.st1204;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.jmisb.api.klv.BerDecoder;
import org.jmisb.api.klv.BerField;
import org.jmisb.core.klv.ArrayUtils;
import org.jmisb.core.klv.UuidUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * ST1204 Core Identifier.
 *
 * <p>Adapted from ST1204.3:
 *
 * <blockquote>
 *
 * <p>A Core Identifier is a collection of up to three Identifier Components combined to form a
 * unique name for the Motion Imagery Data. An Identifier Component is a UUID generated either
 * during the manufacture of a device, or on an as-needed basis throughout the data flow and
 * inserted at different points during the creation and/or dissemination of the Motion Imagery Data.
 *
 * <p>"Generated" means to create a UUID either from unique device information such as serial
 * numbers, model numbers, etc., or from a random number generator. Inserting Identifier Components
 * means to include the Identifier Components into the Motion Imagery Data consistent with the
 * format of the Motion Imagery within its transport container. Identifier Components are either
 * created or added to an existing Core Identifier.
 *
 * <p>Ideally, at insertion the identifier will be frame accurate which is important for platforms
 * with multiple sensors where switching among sensors may occur at frame boundaries.
 *
 * <p>There are two types of Core Identifiers: Foundational and Minor.
 *
 * <p>A Foundational Core Identifier (FCID) is composed of up to three Identifier Components: Sensor
 * Device Identifier, Platform Device Identifier, and Window Identifier. Constructing a Foundational
 * Core Identifier requires a device and/or Window Identifiers be known, which limits their
 * insertion to either on-board the platform or at a ground control station (e.g., GCS for a UAS).
 *
 * <p>A Minor Core Identifier (MCID) is a single Identifier Component from a randomly generated UUID
 * and created/inserted after the platform; not on-board a platform.
 *
 * <p>The Identifier Components include information on the insertion point in a data stream, so
 * users of the identifiers understand the Core Identifier quality. There are four basic
 * generation/insertion points: (1) automatically within the sensor/platform; (2) on-board the
 * platform from a host computer (e.g., generated by flight computer, inserted by encoder); (3)
 * within a control station; and (4) any point from the control station to the end user. Identifier
 * Components include one of these four identifier quality values, so that end users have knowledge
 * on the origin of the identifier.
 *
 * </blockquote>
 */
public class CoreIdentifier {
    private static final Logger LOGGER = LoggerFactory.getLogger(CoreIdentifier.class);

    private static final int UUID_BYTE_LEN = 16;

    private int version;
    private IdType sensorIdType = IdType.None;
    private IdType platformIdType = IdType.None;
    private boolean hasWindowId;
    private boolean hasMinorId;
    private boolean hasValidCheckValue;
    private UUID sensorUUID;
    private UUID platformUUID;
    private UUID windowUUID;
    private UUID minorUUID;

    /**
     * Construct a CoreIdentifier from a text format string.
     *
     * <p>The FCID format is: VersionUsageValue:SensorID/PlatformID/WindowID:CheckValue.
     *
     * <p>An example is:
     *
     * <pre>
     * 0170:F592-F023-7336-4AF8-AA91-62C0-0F2E-B2DA/16B7-4341-0008-41A0-BE36-5B5A-B96A-3645:D3
     * </pre>
     *
     * <p>The MCID format is: VersionUsageValue:MCID:CheckValue.
     *
     * <p>This method tolerates a missing check value (although this will be flagged in the
     * resulting identifier).
     *
     * @param text the text string.
     * @return A core identifier, or null if the string was not correctly formatted.
     */
    public static CoreIdentifier fromString(final String text) {
        CoreIdentifier coreIdentifier = new CoreIdentifier();
        String[] parts = text.split(":");
        if (parts.length < 2) {
            return null;
        }
        String versionAndUsage = parts[0];
        if (versionAndUsage.length() != 4) {
            return null;
        }
        coreIdentifier.parseVersionAndUsage(versionAndUsage);
        String identifierPart = parts[1];
        String[] identifierParts = identifierPart.split("/");
        int expectedNumber = 0;
        if (coreIdentifier.getSensorIdType() != IdType.None) {
            expectedNumber++;
        }
        if (coreIdentifier.getPlatformIdType() != IdType.None) {
            expectedNumber++;
        }
        if (coreIdentifier.hasWindowId) {
            expectedNumber++;
        }
        if (coreIdentifier.hasMinorId) {
            expectedNumber++;
        }
        if (expectedNumber != identifierParts.length) {
            return null;
        }
        int index = 0;
        if (coreIdentifier.getSensorIdType() != IdType.None) {
            coreIdentifier.sensorUUID = UuidUtils.parseUUID(identifierParts[index]);
            index++;
        }
        if (coreIdentifier.getPlatformIdType() != IdType.None) {
            coreIdentifier.platformUUID = UuidUtils.parseUUID(identifierParts[index]);
            index++;
        }
        if (coreIdentifier.hasWindowId) {
            coreIdentifier.setWindowUUID(UuidUtils.parseUUID(identifierParts[index]));
        }
        if (coreIdentifier.hasMinorId) {
            coreIdentifier.setMinorUUID(UuidUtils.parseUUID(identifierParts[index]));
        }
        if (parts.length == 3) {
            int checkFromString = Integer.parseInt(parts[2], 16);
            int checkActual = CheckValue.checkString(parts[0] + parts[1]);
            coreIdentifier.setHasValidCheckValue(checkFromString == checkActual);
        }
        return coreIdentifier;
    }

    /**
     * Construct a core identifier from the binary representation.
     *
     * @param bytes byte array corresponding to the core identifier.
     * @return core identifier, or null if there are insufficient bytes
     */
    public static CoreIdentifier fromBytes(byte[] bytes) {
        if (bytes.length < 2) {
            LOGGER.error("Insufficient bytes to read MIIS Core Identifer usage");
            return null;
        }
        int index = 0;
        CoreIdentifier coreIdentifier = new CoreIdentifier();
        BerField field = BerDecoder.decode(bytes, index, true);
        index += field.getLength();
        coreIdentifier.setVersion(field.getValue());
        byte usage = bytes[index];
        index++;
        coreIdentifier.parseUsage(usage);
        if (coreIdentifier.getSensorIdType() != IdType.None) {
            if (index + UUID_BYTE_LEN > bytes.length) {
                LOGGER.error("Insufficient bytes to read MIIS Sensor UUID");
                return null;
            }
            coreIdentifier.sensorUUID = UuidUtils.arrayToUuid(bytes, index);
            index += UUID_BYTE_LEN;
        }
        if (coreIdentifier.getPlatformIdType() != IdType.None) {
            if (index + UUID_BYTE_LEN > bytes.length) {
                LOGGER.error("Insufficient bytes to read MIIS Platform UUID");
                return null;
            }
            coreIdentifier.platformUUID = UuidUtils.arrayToUuid(bytes, index);
            index += UUID_BYTE_LEN;
        }
        if (coreIdentifier.hasWindowId) {
            if (index + UUID_BYTE_LEN > bytes.length) {
                LOGGER.error("Insufficient bytes to read MIIS Window UUID");
                return null;
            }
            coreIdentifier.windowUUID = UuidUtils.arrayToUuid(bytes, index);
            index += UUID_BYTE_LEN;
        }
        if (coreIdentifier.hasMinorId) {
            if (index + UUID_BYTE_LEN > bytes.length) {
                LOGGER.error("Insufficient bytes to read MIIS Minor UUID");
                return null;
            }
            coreIdentifier.minorUUID = UuidUtils.arrayToUuid(bytes, index);
        }
        // No checksum needed for binary format
        coreIdentifier.hasValidCheckValue = true;
        return coreIdentifier;
    }

    /**
     * Construct a UUID from multiple UUID strings.
     *
     * <p>This corresponds to the ST1204.3 combination algorithm.
     *
     * @param uuids list of strings containing UUIDs
     * @return UUID corresponding to the combined list of inputs, or null if combining failed.
     */
    public static UUID combineMultipleUUID(List<String> uuids) {
        try {
            MessageDigest hasher = MessageDigest.getInstance("SHA-1");
            for (String uuidString : uuids) {
                byte[] uuidBytes = UuidUtils.uuidStringToByteArray(uuidString);
                hasher.update(uuidBytes);
            }
            byte[] uuidBytes = hasher.digest();
            return UuidUtils.convertHashOutputToVersion5UUID(uuidBytes);
        } catch (NoSuchAlgorithmException ex) {
            LOGGER.warn(null, ex);
        }
        return null;
    }

    /**
     * Get the version of the core identifier format.
     *
     * <p>As of ST1204.3, the only recognised format is 1.
     *
     * @return integer value for the format.
     */
    public int getVersion() {
        return version;
    }

    /**
     * Set the version of the core identifier format.
     *
     * <p>As of ST1204.3, the only recognised format is 1.
     *
     * @param version integer value for the format.
     */
    public void setVersion(int version) {
        this.version = version;
    }

    /**
     * Get the sensor identifier type.
     *
     * @return the type of sensor ID used, which can be None.
     */
    public IdType getSensorIdType() {
        return sensorIdType;
    }

    /**
     * Get the platform identifier type.
     *
     * <p>Not all sensors are mounted on platforms, so this can be None.
     *
     * @return the type of platform ID used, which can be None.
     */
    public IdType getPlatformIdType() {
        return platformIdType;
    }

    /**
     * Get the sensor UUID.
     *
     * @return sensor UUID, or null if this is not a valid FCID, or sensor identifier is not
     *     specified.
     */
    public UUID getSensorUUID() {
        return sensorUUID;
    }

    /**
     * Set the sensor identifier and type.
     *
     * @param idType the type of sensor ID used.
     * @param uuid the uuid of the sensor identifier.
     */
    public void setSensorUUID(IdType idType, UUID uuid) {
        this.sensorIdType = idType;
        this.sensorUUID = uuid;
    }

    /**
     * Get the platform UUID.
     *
     * @return platform UUID, or null if this is not a valid FCID, or platform identifier is not
     *     specified.
     */
    public UUID getPlatformUUID() {
        return platformUUID;
    }

    /**
     * Set the platform identifier and type.
     *
     * @param idType the type of platform ID used.
     * @param uuid the uuid of the platform identifier.
     */
    public void setPlatformUUID(IdType idType, UUID uuid) {
        this.platformIdType = idType;
        this.platformUUID = uuid;
    }

    /**
     * Get the window UUID for this core identifier.
     *
     * <p>Window UUIDs are only used for combinations of sensors (e.g. LVMI). This value is often
     * null, corresponding to no window identification.
     *
     * @return window UUID, or null
     */
    public UUID getWindowUUID() {
        return windowUUID;
    }

    /**
     * Set the window UUID for this core identifier.
     *
     * <p>Window UUIDs are only used for combinations of sensors (e.g. LVMI). This value is often
     * null, corresponding to no window identification.
     *
     * @param uuid window UUID, or null
     */
    public void setWindowUUID(final UUID uuid) {
        this.hasWindowId = uuid != null;
        this.windowUUID = uuid;
    }

    /**
     * Get the standard text representation of this core identifier.
     *
     * @return string representation of this identifier.
     */
    public String getTextRepresentation() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("%02X", version));
        int usage = buildUsage();
        sb.append(String.format("%02X", usage));
        sb.append(":");
        boolean needSlash = false;
        if (sensorUUID != null) {
            sb.append(UuidUtils.formatUUID(sensorUUID));
            needSlash = true;
        }
        if (platformUUID != null) {
            if (needSlash) {
                sb.append("/");
            }
            sb.append(UuidUtils.formatUUID(platformUUID));
            needSlash = true;
        }
        if (windowUUID != null) {
            if (needSlash) {
                sb.append("/");
            }
            sb.append(UuidUtils.formatUUID(windowUUID));
        }
        if (minorUUID != null) {
            sb.append(UuidUtils.formatUUID(minorUUID));
        }
        sb.append(":");
        String s = sb.toString();
        int checkValue = CheckValue.checkString(s);
        sb.append(String.format("%02X", checkValue));
        return sb.toString();
    }

    private void parseVersionAndUsage(String versionAndUsage) {
        Integer versionAndUsageValue = Integer.parseInt(versionAndUsage, 16);
        setVersion(versionAndUsageValue >> 8);
        int usage = versionAndUsageValue & 0xFF;
        parseUsage(usage);
    }

    private void parseUsage(int usage) {
        sensorIdType = IdType.fromValue((usage >> 5) & 0x03);
        platformIdType = IdType.fromValue((usage >> 3) & 0x03);
        hasWindowId = (((usage >> 2) & 0x01) == 0x01);
        hasMinorId = (((usage >> 1) & 0x01) == 0x01);
    }

    /**
     * Get the Minor UUID for this core identifier.
     *
     * <p>Note that the minor UUID can be null, and will be if this not a valid MCID.
     *
     * @return UUID, or null.
     */
    public UUID getMinorUUID() {
        return minorUUID;
    }

    /**
     * Set the Minor UUID for this core identifier.
     *
     * <p>Note that the minor UUID can be null, and will be if this not a valid MCID.
     *
     * @param minorUUID minor UUID, or null.
     */
    public void setMinorUUID(final UUID minorUUID) {
        this.hasMinorId = minorUUID != null;
        this.minorUUID = minorUUID;
    }

    /**
     * Get whether this core identifier has a valid check value.
     *
     * @return true if the check value is valid, otherwise false
     */
    public boolean hasValidCheckValue() {
        return this.hasValidCheckValue;
    }

    /**
     * Set whether this core identifier has a valid check value.
     *
     * @param b true if the check value is valid, otherwise false
     */
    public void setHasValidCheckValue(boolean b) {
        this.hasValidCheckValue = b;
    }

    private int buildUsage() {
        int usage = 0;
        usage += (sensorIdType.getValue() << 5);
        usage += (platformIdType.getValue() << 3);
        usage += ((windowUUID != null) ? 0x4 : 0x0);
        if (usage == 0) {
            usage = ((minorUUID != null) ? 0x2 : 0x0);
        }
        return usage;
    }

    /**
     * Get the standard binary representation of this core identifier.
     *
     * @return byte array representation of this identifier.
     */
    public byte[] getRawBytesRepresentation() {
        int len = 0;
        List<byte[]> chunks = new ArrayList<>();
        chunks.add(new byte[] {(byte) version});
        len += 1;
        chunks.add(new byte[] {(byte) buildUsage()});
        len += 1;
        if (sensorUUID != null) {
            chunks.add(UuidUtils.uuidToArray(sensorUUID));
            len += 16;
        }
        if (platformUUID != null) {
            chunks.add(UuidUtils.uuidToArray(platformUUID));
            len += 16;
        }
        if (windowUUID != null) {
            chunks.add(UuidUtils.uuidToArray(windowUUID));
            len += 16;
        }
        if (minorUUID != null) {
            chunks.add(UuidUtils.uuidToArray(minorUUID));
            len += 16;
        }
        return ArrayUtils.arrayFromChunks(chunks, len);
    }
}
