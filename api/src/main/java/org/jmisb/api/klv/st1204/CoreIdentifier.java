package org.jmisb.api.klv.st1204;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.jmisb.api.klv.BerDecoder;
import org.jmisb.api.klv.BerField;

/**
 * ST1204 Core Identifier.
 * <p>
 * Adapted from ST1204.2:
 * </p>
 * <p>
 * A Core Identifier is a collection of up to three Identifier Components
 * combined to form a unique name for the Motion Imagery Data. An Identifier
 * Component is a UUID generated either during the manufacture of a device, or
 * on an as-needed basis throughout the data flow and inserted at different
 * points during the creation and/or dissemination of the Motion Imagery Data.
 * </p>
 * <p>
 * “Generated” means to create a UUID either from unique device information such
 * as serial numbers, model numbers, etc., or from a random number generator.
 * Inserting Identifier Components means to include the Identifier Components
 * into the Motion Imagery Data consistent with the format of the Motion Imagery
 * within its transport container. Identifier Components are either created or
 * added to an existing Core Identifier.
 * </p>
 * <p>
 * Ideally, at insertion the identifier will be frame accurate which is
 * important for platforms with multiple sensors where switching among sensors
 * may occur at frame boundaries.
 * </p>
 * <p>
 * There are two types of Core Identifiers: Foundational and Minor.
 * </p>
 * <p>
 * A Foundational Core Identifier is composed of up to three Identifier
 * Components: Sensor Device Identifier, Platform Device Identifier, and Window
 * Identifier. Constructing a Foundational Core Identifier requires a device
 * and/or Window Identifiers be known, which limits their insertion to either
 * on-board the platform or at a ground control station (e.g., GCS for a UAS).
 * </p>
 * <p>
 * A Minor Core Identifier is a single Identifier Component from a randomly
 * generated UUID and created/inserted after the platform; not on-board a
 * platform.
 * </p>
 * <p>
 * The Identifier Components include information on the insertion point in a
 * data stream, so users of the identifiers understand the Core Identifier
 * quality. There are four basic generation/insertion points: (1) automatically
 * within the sensor/platform; (2) on-board the platform from a host computer
 * (e.g., generated by flight computer, inserted by encoder); (3) within a
 * control station; and (4) any point from the control station to the end user.
 * Identifier Components include one of these four identifier quality values, so
 * that end users have knowledge on the origin of the identifier.
 * </p>
 *
 */
public class CoreIdentifier {

    private int version;
    private IdType sensorIdType = IdType.None;
    private IdType platformIdType = IdType.None;
    private boolean hasWindowId;
    private boolean hasMinorId;
    private boolean hasValidCheckValue;
    private UUID sensorUUID;
    private UUID platformUUID;
    private UUID windowUUID;
    private UUID minorUUID;

    public static CoreIdentifier fromString(final String text) {
        CoreIdentifier coreIdentifier = new CoreIdentifier();
        String[] parts = text.split(":");
        if (parts.length < 2) {
            return null;
        }
        String versionAndUsage = parts[0];
        if (versionAndUsage.length() != 4) {
            return null;
        }
        coreIdentifier.parseVersionAndUsage(versionAndUsage);
        String identifierPart = parts[1];
        String[] identifierParts = identifierPart.split("/");
        int expectedNumber = 0;
        if (coreIdentifier.getSensorIdType() != IdType.None) {
            expectedNumber++;
        }
        if (coreIdentifier.getPlatformIdType() != IdType.None) {
            expectedNumber++;
        }
        if (coreIdentifier.hasWindowId) {
            expectedNumber++;
        }
        if (coreIdentifier.hasMinorId) {
            expectedNumber++;
        }
        if (expectedNumber != identifierParts.length) {
            return null;
        }
        int index = 0;
        if (coreIdentifier.getSensorIdType() != IdType.None) {
            coreIdentifier.sensorUUID = UuidUtils.parseUUID(identifierParts[index]);
            index++;
        }
        if (coreIdentifier.getPlatformIdType() != IdType.None) {
            coreIdentifier.platformUUID = UuidUtils.parseUUID(identifierParts[index]);
            index++;
        }
        if (coreIdentifier.hasWindowId) {
            coreIdentifier.setWindowUUID(UuidUtils.parseUUID(identifierParts[index]));
        }
        if (coreIdentifier.hasMinorId) {
            coreIdentifier.setMinorUUID(UuidUtils.parseUUID(identifierParts[index]));
        }
        if (parts.length == 3) {
            int checkFromString = Integer.parseInt(parts[2], 16);
            int checkActual = CheckValue.checkString(parts[0] + parts[1]);
            coreIdentifier.setHasValidCheckValue(checkFromString == checkActual);
        }
        return coreIdentifier;
    }

    public static CoreIdentifier fromBytes(byte[] bytes) {
        int index = 0;
        CoreIdentifier coreIdentifier = new CoreIdentifier();
        BerField field = BerDecoder.decode(bytes, index, true);
        index += field.getLength();
        coreIdentifier.setVersion(field.getValue());
        byte usage = bytes[index];
        index ++;
        coreIdentifier.parseUsage(usage);
        if (coreIdentifier.getSensorIdType() != IdType.None) {
            coreIdentifier.sensorUUID = UuidUtils.arrayToUuid(bytes, index);
            index += 16;
        }
        if (coreIdentifier.getPlatformIdType() != IdType.None) {
            coreIdentifier.platformUUID = UuidUtils.arrayToUuid(bytes, index);
            index += 16;
        }
        if (coreIdentifier.hasWindowId) {
            coreIdentifier.windowUUID = UuidUtils.arrayToUuid(bytes, index);
        }
        if (coreIdentifier.hasMinorId) {
            coreIdentifier.minorUUID = UuidUtils.arrayToUuid(bytes, index);
        }
        // No checksum needed for binary format
        coreIdentifier.hasValidCheckValue = true;
        return coreIdentifier;
    }

    public int getVersion() {
        return version;
    }

    public void setVersion(int version) {
        this.version = version;
    }

    public IdType getSensorIdType() {
        return sensorIdType;
    }

    public IdType getPlatformIdType() {
        return platformIdType;
    }

    public UUID getSensorUUID() {
        return sensorUUID;
    }

    public void setSensorUUID(IdType idType, UUID uuid) {
        this.sensorIdType = idType;
        this.sensorUUID = uuid;
    }

    public UUID getPlatformUUID() {
        return platformUUID;
    }

    public void setPlatformUUID(IdType idType, UUID uuid) {
        this.platformIdType = idType;
        this.platformUUID = uuid;
    }

    public UUID getWindowUUID() {
        return windowUUID;
    }

    public void setWindowUUID(final UUID uuid) {
        this.hasWindowId = uuid != null;
        this.windowUUID = uuid;
    }

    public String getTextRepresentation() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("%02X", version));
        int usage = buildUsage();
        sb.append(String.format("%02X", usage));
        sb.append(":");
        boolean needSlash = false;
        if (sensorUUID != null) {
            sb.append(UuidUtils.formatUUID(sensorUUID));
            needSlash = true;
        }
        if (platformUUID != null) {
            if (needSlash) {
                sb.append("/");
            }
            sb.append(UuidUtils.formatUUID(platformUUID));
            needSlash = true;
        }
        if (windowUUID != null) {
            if (needSlash) {
                sb.append("/");
            }
            sb.append(UuidUtils.formatUUID(windowUUID));
        }
        if (minorUUID != null) {
            sb.append(UuidUtils.formatUUID(minorUUID));
        }
        sb.append(":");
        String s = sb.toString();
        int checkValue = CheckValue.checkString(s);
        sb.append(String.format("%02X", checkValue));
        return sb.toString();
    }

    private void parseVersionAndUsage(String versionAndUsage) {
        Integer versionAndUsageValue = Integer.parseInt(versionAndUsage, 16);
        setVersion(versionAndUsageValue >> 8);
        int usage = versionAndUsageValue & 0xFF;
        parseUsage(usage);
    }

    private void parseUsage(int usage) {
        sensorIdType = IdType.fromValue((usage >> 5) & 0x03);
        platformIdType = IdType.fromValue((usage >> 3) & 0x03);
        hasWindowId = (((usage >> 2) & 0x01) == 0x01);
        hasMinorId = (((usage >> 1) & 0x01) == 0x01);
    }

    public UUID getMinorUUID() {
        return minorUUID;
    }

    public void setMinorUUID(final UUID minorUUID) {
        this.hasMinorId = minorUUID != null;
        this.minorUUID = minorUUID;
    }

    public boolean hasValidCheckValue() {
        return this.hasValidCheckValue;
    }

    public void setHasValidCheckValue(boolean b) {
        this.hasValidCheckValue = b;
    }

    private int buildUsage() {
        int usage = 0;
        usage += (sensorIdType.getValue() << 5);
        usage += (platformIdType.getValue() << 3);
        usage += ((windowUUID != null) ? 0x4 : 0x0);
        if (usage == 0) {
            usage = ((minorUUID != null) ? 0x2 : 0x0);
        }
        return usage;
    }

    public byte[] getRawBytesRepresentation() {
        try {
            ByteArrayOutputStream byteBuilder = new ByteArrayOutputStream();
            byteBuilder.write((byte) version);
            byteBuilder.write((byte) buildUsage());
            if (sensorUUID != null) {
                byteBuilder.write(UuidUtils.uuidToArray(sensorUUID));
            }
            if (platformUUID != null) {
                byteBuilder.write(UuidUtils.uuidToArray(platformUUID));
            }
            if (windowUUID != null) {
                byteBuilder.write(UuidUtils.uuidToArray(windowUUID));
            }
            if (minorUUID != null) {
                byteBuilder.write(UuidUtils.uuidToArray(minorUUID));
            }
            return byteBuilder.toByteArray();
        } catch (IOException ex) {
            Logger.getLogger(CoreIdentifier.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

}
