package org.jmisb.api.klv.st1204;

import org.jmisb.core.klv.UuidUtils;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.jmisb.api.klv.BerDecoder;
import org.jmisb.api.klv.BerField;
import org.jmisb.core.klv.ArrayUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * ST1204 Core Identifier.
 * <p>
 * Adapted from ST1204.2:
 * </p>
 * <p>
 * A Core Identifier is a collection of up to three Identifier Components
 * combined to form a unique name for the Motion Imagery Data. An Identifier
 * Component is a UUID generated either during the manufacture of a device, or
 * on an as-needed basis throughout the data flow and inserted at different
 * points during the creation and/or dissemination of the Motion Imagery Data.
 * </p>
 * <p>
 * “Generated” means to create a UUID either from unique device information such
 * as serial numbers, model numbers, etc., or from a random number generator.
 * Inserting Identifier Components means to include the Identifier Components
 * into the Motion Imagery Data consistent with the format of the Motion Imagery
 * within its transport container. Identifier Components are either created or
 * added to an existing Core Identifier.
 * </p>
 * <p>
 * Ideally, at insertion the identifier will be frame accurate which is
 * important for platforms with multiple sensors where switching among sensors
 * may occur at frame boundaries.
 * </p>
 * <p>
 * There are two types of Core Identifiers: Foundational and Minor.
 * </p>
 * <p>
 * A Foundational Core Identifier (FCID) is composed of up to three Identifier
 * Components: Sensor Device Identifier, Platform Device Identifier, and Window
 * Identifier. Constructing a Foundational Core Identifier requires a device
 * and/or Window Identifiers be known, which limits their insertion to either
 * on-board the platform or at a ground control station (e.g., GCS for a UAS).
 * </p>
 * <p>
 * A Minor Core Identifier (MCID) is a single Identifier Component from a
 * randomly generated UUID and created/inserted after the platform; not on-board
 * a platform.
 * </p>
 * <p>
 * The Identifier Components include information on the insertion point in a
 * data stream, so users of the identifiers understand the Core Identifier
 * quality. There are four basic generation/insertion points: (1) automatically
 * within the sensor/platform; (2) on-board the platform from a host computer
 * (e.g., generated by flight computer, inserted by encoder); (3) within a
 * control station; and (4) any point from the control station to the end user.
 * Identifier Components include one of these four identifier quality values, so
 * that end users have knowledge on the origin of the identifier.
 * </p>
 *
 */
public class CoreIdentifier
{
    private static Logger logger = LoggerFactory.getLogger(CoreIdentifier.class);

    private int version;
    private IdType sensorIdType = IdType.None;
    private IdType platformIdType = IdType.None;
    private boolean hasWindowId;
    private boolean hasMinorId;
    private boolean hasValidCheckValue;
    private UUID sensorUUID;
    private UUID platformUUID;
    private UUID windowUUID;
    private UUID minorUUID;

    /**
     * Construct a CoreIdentifier from a text format string.
     * <p>
     * The FCID format is:
     * VersionUsageValue:SensorID/PlatformID/WindowID:CheckValue.
     * <p>
     * An example is:
     * </p>
     * <pre>
     * 0170:F592-F023-7336-4AF8-AA91-62C0-0F2E-B2DA/16B7-4341-0008-41A0-BE36-5B5A-B96A-3645:D3
     * </pre>
     * <p>
     * The MCID format is: VersionUsageValue:MCID:CheckValue.
     * </p>
     * <p>
     * This method tolerates a missing check value (although this will be
     * flagged in the resulting identifier).
     *
     * @param text the text string.
     * @return A core identifier, or null if the string was not correctly
     * formatted.
     */
    public static CoreIdentifier fromString(final String text)
    {
        CoreIdentifier coreIdentifier = new CoreIdentifier();
        String[] parts = text.split(":");
        if (parts.length < 2) {
            return null;
        }
        String versionAndUsage = parts[0];
        if (versionAndUsage.length() != 4) {
            return null;
        }
        coreIdentifier.parseVersionAndUsage(versionAndUsage);
        String identifierPart = parts[1];
        String[] identifierParts = identifierPart.split("/");
        int expectedNumber = 0;
        if (coreIdentifier.getSensorIdType() != IdType.None) {
            expectedNumber++;
        }
        if (coreIdentifier.getPlatformIdType() != IdType.None) {
            expectedNumber++;
        }
        if (coreIdentifier.hasWindowId) {
            expectedNumber++;
        }
        if (coreIdentifier.hasMinorId) {
            expectedNumber++;
        }
        if (expectedNumber != identifierParts.length) {
            return null;
        }
        int index = 0;
        if (coreIdentifier.getSensorIdType() != IdType.None) {
            coreIdentifier.sensorUUID = UuidUtils.parseUUID(identifierParts[index]);
            index++;
        }
        if (coreIdentifier.getPlatformIdType() != IdType.None) {
            coreIdentifier.platformUUID = UuidUtils.parseUUID(identifierParts[index]);
            index++;
        }
        if (coreIdentifier.hasWindowId) {
            coreIdentifier.setWindowUUID(UuidUtils.parseUUID(identifierParts[index]));
        }
        if (coreIdentifier.hasMinorId) {
            coreIdentifier.setMinorUUID(UuidUtils.parseUUID(identifierParts[index]));
        }
        if (parts.length == 3) {
            int checkFromString = Integer.parseInt(parts[2], 16);
            int checkActual = CheckValue.checkString(parts[0] + parts[1]);
            coreIdentifier.setHasValidCheckValue(checkFromString == checkActual);
        }
        return coreIdentifier;
    }

    /**
     * Construct a core identifier from the binary representation.
     *
     * @param bytes byte array corresponding to the core identifier.
     * @return core identifier.
     */
    public static CoreIdentifier fromBytes(byte[] bytes)
    {
        int index = 0;
        CoreIdentifier coreIdentifier = new CoreIdentifier();
        BerField field = BerDecoder.decode(bytes, index, true);
        index += field.getLength();
        coreIdentifier.setVersion(field.getValue());
        byte usage = bytes[index];
        index ++;
        coreIdentifier.parseUsage(usage);
        if (coreIdentifier.getSensorIdType() != IdType.None) {
            coreIdentifier.sensorUUID = UuidUtils.arrayToUuid(bytes, index);
            index += 16;
        }
        if (coreIdentifier.getPlatformIdType() != IdType.None) {
            coreIdentifier.platformUUID = UuidUtils.arrayToUuid(bytes, index);
            index += 16;
        }
        if (coreIdentifier.hasWindowId) {
            coreIdentifier.windowUUID = UuidUtils.arrayToUuid(bytes, index);
        }
        if (coreIdentifier.hasMinorId) {
            coreIdentifier.minorUUID = UuidUtils.arrayToUuid(bytes, index);
        }
        // No checksum needed for binary format
        coreIdentifier.hasValidCheckValue = true;
        return coreIdentifier;
    }

    /**
     * Construct a UUID from multiple UUID strings.
     *
     * This corresponds to the ST1204.3 combination algorithm.
     *
     * @param uuids list of strings containing UUIDs
     * @return UUID corresponding to the combined list of inputs, or null if combining failed.
     */
    public static UUID combineMultipleUUID(List<String> uuids)
    {
        try
        {
            MessageDigest hasher = MessageDigest.getInstance("SHA-1");
            for (String uuidString: uuids)
            {
                byte[] uuidBytes = UuidUtils.uuidStringToByteArray(uuidString);
                hasher.update(uuidBytes);
            }
            byte[] uuidBytes = hasher.digest();
            return UuidUtils.convertHashOutputToVersion5UUID(uuidBytes);
        }
        catch (NoSuchAlgorithmException ex)
        {
            logger.warn(null, ex);
        }
        return null;
    }

    public int getVersion() {
        return version;
    }

    public void setVersion(int version) {
        this.version = version;
    }

    public IdType getSensorIdType() {
        return sensorIdType;
    }

    public IdType getPlatformIdType() {
        return platformIdType;
    }

    public UUID getSensorUUID() {
        return sensorUUID;
    }

    public void setSensorUUID(IdType idType, UUID uuid) {
        this.sensorIdType = idType;
        this.sensorUUID = uuid;
    }

    public UUID getPlatformUUID() {
        return platformUUID;
    }

    public void setPlatformUUID(IdType idType, UUID uuid) {
        this.platformIdType = idType;
        this.platformUUID = uuid;
    }

    public UUID getWindowUUID() {
        return windowUUID;
    }

    public void setWindowUUID(final UUID uuid) {
        this.hasWindowId = uuid != null;
        this.windowUUID = uuid;
    }

    public String getTextRepresentation() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("%02X", version));
        int usage = buildUsage();
        sb.append(String.format("%02X", usage));
        sb.append(":");
        boolean needSlash = false;
        if (sensorUUID != null) {
            sb.append(UuidUtils.formatUUID(sensorUUID));
            needSlash = true;
        }
        if (platformUUID != null) {
            if (needSlash) {
                sb.append("/");
            }
            sb.append(UuidUtils.formatUUID(platformUUID));
            needSlash = true;
        }
        if (windowUUID != null) {
            if (needSlash) {
                sb.append("/");
            }
            sb.append(UuidUtils.formatUUID(windowUUID));
        }
        if (minorUUID != null) {
            sb.append(UuidUtils.formatUUID(minorUUID));
        }
        sb.append(":");
        String s = sb.toString();
        int checkValue = CheckValue.checkString(s);
        sb.append(String.format("%02X", checkValue));
        return sb.toString();
    }

    private void parseVersionAndUsage(String versionAndUsage) {
        Integer versionAndUsageValue = Integer.parseInt(versionAndUsage, 16);
        setVersion(versionAndUsageValue >> 8);
        int usage = versionAndUsageValue & 0xFF;
        parseUsage(usage);
    }

    private void parseUsage(int usage) {
        sensorIdType = IdType.fromValue((usage >> 5) & 0x03);
        platformIdType = IdType.fromValue((usage >> 3) & 0x03);
        hasWindowId = (((usage >> 2) & 0x01) == 0x01);
        hasMinorId = (((usage >> 1) & 0x01) == 0x01);
    }

    public UUID getMinorUUID() {
        return minorUUID;
    }

    public void setMinorUUID(final UUID minorUUID) {
        this.hasMinorId = minorUUID != null;
        this.minorUUID = minorUUID;
    }

    public boolean hasValidCheckValue() {
        return this.hasValidCheckValue;
    }

    public void setHasValidCheckValue(boolean b) {
        this.hasValidCheckValue = b;
    }

    private int buildUsage() {
        int usage = 0;
        usage += (sensorIdType.getValue() << 5);
        usage += (platformIdType.getValue() << 3);
        usage += ((windowUUID != null) ? 0x4 : 0x0);
        if (usage == 0) {
            usage = ((minorUUID != null) ? 0x2 : 0x0);
        }
        return usage;
    }

    public byte[] getRawBytesRepresentation() {
        int len = 0;
        List<byte[]> chunks = new ArrayList<>();
        chunks.add(new byte[]{(byte) version});
        len += 1;
        chunks.add(new byte[]{(byte) buildUsage()});
        len += 1;
        if (sensorUUID != null) {
            chunks.add(UuidUtils.uuidToArray(sensorUUID));
            len += 16;
        }
        if (platformUUID != null) {
            chunks.add(UuidUtils.uuidToArray(platformUUID));
            len += 16;
        }
        if (windowUUID != null) {
            chunks.add(UuidUtils.uuidToArray(windowUUID));
            len += 16;
        }
        if (minorUUID != null) {
            chunks.add(UuidUtils.uuidToArray(minorUUID));
            len += 16;
        }
        return ArrayUtils.arrayFromChunks(chunks, len);
    }

}
