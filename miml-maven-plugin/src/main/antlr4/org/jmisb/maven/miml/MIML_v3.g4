/**
 * Copyright (c) 2021 National Geospatial Agency (NGA). This file is made available as is with no liability on NGA's part.
 * Users can make changes as needed with sole responsibility to provide NGA a copy if enhancements are made or issues are
 * corrected. 
 * 
 * This file and the Lexer rules file are ANTLR4 files that define the grammar for the Motion Imagery Modeling Language (MIML). MIML is the method for 
 * describing the Motion Imagery MetaData (MIMD) Model defined by the Motion Imagery Standards Board (MISB). Please refer to the MISB standards ST1901 
 * through ST1908 for further information on the MIMD model.
 * 
 * Do NOT edit this file unless you understand what you are doing - small changes to this file
 * will easily break the MIML grammar.
 *  
 * Note: Update the version number lexer rule "MIMLVER" if changes are made.
 */
grammar MIML_v3;
options {tokenVocab=MIMLLexerRules_v3;}

declaration: fileOptions (mimdclass | enumeration)+; 
fileOptions: grammarVer modelVer;

grammarVer: MIMLVERPREFIX MIMLVER SEMI;   
modelVer: MODELVERPREFIX MODELVERNUM SEMI;   
 
mimdclass: CLASS CLASSNAME extender? includes? body;  

extender: EXTENDS CLASSNAME;

includes: INCLUDES CLASSNAME;

body:BODYSTART classdoc  attrib+ ENDBODY;   

classdoc: DOCUMENT EQ DOCNAME SEMICOLON; 

attrib: TAGID UNDERSCORE IDENT COLON typeinfo attrInfo ENDATTR;

typeinfo: singular | object | special ;

singular :
     TUPLESTR          LPAREN maxLen         RPAREN    # SingularTuple 
   | STRINGSTR         LPAREN maxLen         RPAREN    # SingularString
   | REALSTR   array* (LPAREN realMinMaxRes? RPAREN)?  # SingularReal
   | INTSTR    array* (LPAREN intMinMaxRes?  RPAREN)?  # SingularInteger
   | UINTSTR   array* (LPAREN uIntMinMax?    RPAREN)?  # SingularUInt
   | BINARYSTR array*                                  # SingularBinary
   | RESERVEDSTR                                       # SingularReserved 
   ;

//Allow up to three parameters
realMinMaxRes
   : realNone
   | realNone COMMA realNone
   | realNone COMMA realNone COMMA realNone;

realNone:  REALNUM | NONE | (PLUSMINUS? ( TWOPISTR | HALFPISTR | PISTR));

//Allow up to three parameters
intMinMaxRes
   : intNone
   | intNone COMMA intNone
   | intNone COMMA intNone COMMA intNone; 

intNone : intVal | NONE;

intVal: PLUSMINUS? UINTVAL;

//Allow up to two parameters
uIntMinMax
   : uintNone
   | uintNone COMMA uintNone;

uintNone: UINTVAL | NONE;

maxLen: UINTVAL;

array: (LBRACKET (UINTVAL | LESSTHAN UINTVAL)? RBRACKET);   

object: CLASSIDENT;

special
   : LISTSTR LARR CLASSIDENT RARR (LPAREN multiplicity RPAREN)? #SpecialList
   | SPECSTR LARR CLASSIDENT RARR         #SpecialSpec
   | REFSTR  LARR CLASSIDENT RARR  array* #SpecialRef
   ;

multiplicity: UINTVAL | UINTVAL COMMA uintStar;

uintStar: UINTVAL | STAR;

attrInfo: STARTINFO unitVal (ACOMMA reference)? (ACOMMA DEPRECATE)? ENDINFO;

unitVal : (units | NOUNITS | SEEDESCRIPTIONSTR);

units: units UNITSTAR units 
     | units UNITSLASH units
     | units UNITCARROT units
     | WORD;

reference: STRINGVALUE ;

//Enumeration 
enumeration:ENUMERATION ENUMNAME enumbody;

enumbody: ENUMBODY enumdoc enumvals+ ENDENUM; 

enumdoc: ENUMDOC ENUMEQ ENUMDOCNAME ENUMSEMI; 

enumvals: VALUE ITEMEQ NAME (ENUMTEXT)? ENDENUMITEM;


